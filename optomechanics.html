<html>
<title>Optomechanics in your browser</title>
	<head>
				<meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <!---
    (C) 2020 by Florian Marquardt and Tirth Shah.
    Max Planck Institute for the Science of Light, Erlangen.
    mpl.mpg.de (theory division)

    This is an outreach project within the Marie Curie Network
    Optomechanical Technologies, sponsored by the European Union.
    It was written to serve as a basis for a MOOC video on
    nonlinear dynamics in optomechanics.

    MIT License. You can re-use, but please give credit.
    -->
<style>
.mybutton {
	background-color:#00AA80;
	text-align:center;
	border-radius:5px;
	font-family:Helvetica;
    font-weight:100;
	padding:3px;
	user-select: none;
}
.mybutton:hover {
	background-color:#FF8000;
    cursor:pointer
}

.mybutton_animation {
    animation: 0.2s linear 0s 1 normal sweep_color;
}

@keyframes sweep_color { from { background-color:rgb(255,255,255); } to { background-color:rgb(255,200,0); } } 

.collapsible-button {
    background-color:gray ;
    padding: 5px;
    border-radius: 5px;
    font-family:Helvetica;
    font-weight:100;
    margin:auto;
    margin-bottom:2px;
    cursor:pointer;
}

.collapsible-button:hover {
    background-color:lightgray;
}

.collapsible-content {
  display: none;
  overflow: hidden;
  background-color:gray;
  padding: 5px;
  border-radius: 5px;
}
</style>

<body style="margin:0; background-color:#000000">

<!-- 
First: the panel on the left, onto which the animation will be drawn.
Scripts are at the end of this page!
--->

<div style="width:70%;float:left">
	<svg id="canvas" viewBox="0 0 100 100">
		</svg>
</div>

<!-- 
And now: the text!
--->

<div id="sidebar" style="float:right;max-width:25%;background-color:dimgrey;font-family:Helvetica;font-weight:100;color:#FFFFFF;padding:10px">

	<p style="font-size:20px;font-weight:100;background-color:orange;padding:5px;border-radius:5px">
Cavity Optomechanics Simulator
	</p>

	<div id="detuning_input_div" class="slider">
	<label>Detuning &Delta;/&Omega;=</label> <label id="detuning_text">1</label>
    <input id="detuning_input" style="width:100%" type="range" list="tickmarks" min="-5" max="5" value="1" step="0.01" oninput="change_detuning(true)">
    <datalist id="tickmarks">
        <option value="0" label="0"></option>
        <option value="1" label="1"></option>
        <option value="2" label="2"></option>
        <option value="-1" label="-1"></option>
        <option value="-2" label="-2"></option>
      </datalist>
	</div>

	<div id="kappa_input_div" class="slider">
        <label>Cavity decay &kappa;/&Omega;=</label> <label id="kappa_text">1</label>
        <input id="kappa_input" style="width:100%" type="range" list="tickmarks" min="0" max="3" value="1" step="0.01" oninput="change_kappa(true)">
        <datalist id="tickmarks">
            <option value="0" label="0"></option>
            <option value="0.1" label="0.1"></option>
            <option value="1" label="1"></option>
            <option value="2" label="2"></option>
          </datalist>
    </div>

    <div id="Gamma_input_div" class="slider">
        <label>Mechanical damping &Gamma;/&Omega;=</label> <label id="gamma_text">1</label>
        <input id="gamma_input" style="width:100%" type="range" list="tickmarks" min="-4" max="0" value="-2" step="0.01" oninput="change_gamma(true)">
        <datalist id="tickmarks">
            <option value="-4" label="1e-4"></option>
            <option value="-3" label="1e-3"></option>
            <option value="-2" label="1e-2"></option>
            <option value="-1" label="1e-1"></option>
            <option value="0" label="1"></option>
            </datalist>
    </div>

    <div id="g0_input_div" class="slider">
        <label>Coupling g<sub>0</sub>/&Omega;=</label> <label id="g0_text">1</label>
        <input id="g0_input" style="width:100%" type="range" list="tickmarks" min="0" max="0.001" value="0.0001" step="0.000001" oninput="change_g0(true)">
        <datalist id="tickmarks">
            <option value="0" label="0"></option>
            <option value="0.0001" label="10<sup>-4</sup>"></option>
            <option value="0.001" label="10<sup>-3</sup>"></option>
            </datalist>
    </div>

    <div id="alpha_in_input_div" class="slider">
        <label>Drive (photons/time) |&alpha;<sub>in</sub>|<sup>2</sup>/&Omega;=</label> <label id="alpha_in_text">1</label>
        <input id="alpha_in_input" style="width:100%" type="range" list="tickmarks" min="-3" max="6" value="1.0" step="0.01" oninput="change_alpha_in(true)">
        <datalist id="tickmarks">
            <option value="-3" label="10<sup>-3</sup>"></option>
            <option value="-2" label="10<sup>-2</sup>"></option>
            <option value="-1" label="10<sup>-1</sup>"></option>
            <option value="0" label="0"></option>
            <option value="1" label="10<sup>1</sup>"></option>
            <option value="2" label="10<sup>2</sup>"></option>
            <option value="3" label="10<sup>3</sup>"></option>
            <option value="4" label="10<sup>4</sup>"></option>
            <option value="5" label="10<sup>5</sup>"></option>
            <option value="6" label="10<sup>6</sup>"></option>
            </datalist>
    </div>

    <p class="collapsible-button" onclick="var content = this.nextElementSibling; if (content.style.display === 'block') { content.style.display = 'none';       } else {        content.style.display = 'block';        }">Parameter sweeps ... </button>
    <div class="collapsible-content">

    <p class="mybutton" onclick="define_sweep_start(this)">Set sweep start</p>
    <p class="mybutton" onclick="define_sweep_end(this)">Set sweep end</p>
    <div id="sweep_time_input_div" class="slider">
        <label>Sweep time (times &Omega;)=</label> <label id="sweep_time_text">1</label>
        <input id="sweep_time_input" style="width:100%" type="range" list="tickmarks" min="1" max="6" value="2" step="0.01" oninput="change_sweep_time()">
        <datalist id="tickmarks">
            <option value="1" label="10"></option>
            <option value="2" label="1e2"></option>
            <option value="3" label="1e3"></option>
            <option value="4" label="1e4"></option>
            <option value="5" label="1e5"></option>
            </datalist>
    </div>


    <label>
    <input type="checkbox" onclick="activate_sweep(this)"/>
    <div>Activate sweep</div>
    </label>

    <label>
    <input type="checkbox" onclick="switch_kinetic_average(this)"/>
    <div>Show kinetic motion amplitude</div>
    </label>

    <p class="mybutton" onclick="define_Vsweep_start(this)">Set vertical sweep start</p>
    <p class="mybutton" onclick="define_Vsweep_end(this)">Set vertical sweep end</p>
    <label>
        <input type="checkbox" onclick="activate_sweep2d(this)"/>
        <div>2D sweep</div>
    </label>
    </div>

    <p class="mybutton" onclick="show_parameter_URL()">Show parameter URL</p>
    <p id="parameter_URL_field" style="font-size:8;word-wrap:break-word"></p>

    <p style="font-size:14;color:white">Tirth Shah & Florian Marquardt 2020<br>
        <a href="https://mpl.mpg.de/divisions/marquardt-division/" target="_new" style="color:white">Max Planck Institute for the Science of Light</a><br>
        Marie-Curie network<br>
        "Optomechanical Technologies", <br>
        supported by the European Union
        <!-- European flag from Wikimedia Commons -->
        <svg width="24.30" height="16" viewBox="0 0 810 540"><desc>European flag</desc>
            <defs><g id="s"><g id="c"><path id="t" d="M0,0v1h0.5z" transform="translate(0,-1)rotate(18)"/><use xlink:href="#t" transform="scale(-1,1)"/></g><g id="a"><use xlink:href="#c" transform="rotate(72)"/><use xlink:href="#c" transform="rotate(144)"/></g><use xlink:href="#a" transform="scale(-1,1)"/></g></defs>
            <rect fill="#039" width="810" height="540"/><g fill="#fc0" transform="scale(30)translate(13.5,9)"><use xlink:href="#s" y="-6"/><use xlink:href="#s" y="6"/><g id="l"><use xlink:href="#s" x="-6"/><use xlink:href="#s" transform="rotate(150)translate(0,6)rotate(66)"/><use xlink:href="#s" transform="rotate(120)translate(0,6)rotate(24)"/><use xlink:href="#s" transform="rotate(60)translate(0,6)rotate(12)"/><use xlink:href="#s" transform="rotate(30)translate(0,6)rotate(42)"/></g><use xlink:href="#l" transform="scale(-1,1)"/></g>
        </svg>
    </p>

</div>

<script>
// User interface actions


function change_detuning(also_sweep) {
    Detuning=parseFloat(document.getElementById('detuning_input').value)
    document.getElementById('detuning_text').innerHTML=Detuning
    if(also_sweep) {
        if(sweep_active) {
            fresh_sweep()
        }
    }
}

function change_kappa(also_sweep) {
    kappa=parseFloat(document.getElementById('kappa_input').value)
    document.getElementById('kappa_text').innerHTML=kappa
    LaserDrive=Math.sqrt(kappa)*alpha_in
    if(also_sweep) {
        if(sweep_active) {
            fresh_sweep()
        }
    }
}

function change_gamma(also_sweep) {
    Gamma=Math.pow(10,parseFloat(document.getElementById('gamma_input').value))
    document.getElementById('gamma_text').innerHTML=Gamma.toPrecision(2)
    if(also_sweep) {
        if(sweep_active) {
            fresh_sweep()
        }
    }
}

function change_g0(also_sweep) {
    g0=parseFloat(document.getElementById('g0_input').value)
    document.getElementById('g0_text').innerHTML=g0
    if(also_sweep) {
        if(sweep_active) {
            fresh_sweep()
        }
    }
}

function change_alpha_in(also_sweep) {
    alpha_in_2=Math.pow(10,parseFloat(document.getElementById('alpha_in_input').value))
    document.getElementById('alpha_in_text').innerHTML=alpha_in_2.toPrecision(2)
    alpha_in=Math.sqrt(alpha_in_2)
    LaserDrive=Math.sqrt(kappa)*alpha_in
    if(also_sweep) {
        if(sweep_active) {
            fresh_sweep()
        }
    }
}

function change_sweep_time() {
    sweep_time=Math.pow(10,parseFloat(document.getElementById('sweep_time_input').value))
    document.getElementById('sweep_time_text').innerHTML=sweep_time.toPrecision(2)
    if(sweep_active) {
        fresh_sweep()
    }
}

function query_all_parameters() {
    change_detuning(false) // obtain Detuning value
    change_kappa(false)
    change_gamma(false)
    change_g0(false)
    change_alpha_in(false)
}

function animate_clicked_button(obj) {
    obj.classList.add('mybutton_animation')
    setTimeout(function(){
        	obj.classList.remove('mybutton_animation');
        }, 200)
}

function fresh_sweep() {
    V_idx=0
    do_sweep(V_idx)
}

function define_sweep_start(button_element) {
    query_all_parameters()
    Detuning_start=Detuning
    alpha_in_start=alpha_in
    kappa_start=kappa
    Gamma_start=Gamma
    g0_start=g0
    animate_clicked_button(button_element)
    if(sweep_active) {
        fresh_sweep()
    }
}

function define_sweep_end(button_element) {
    query_all_parameters()
    Detuning_end=Detuning
    alpha_in_end=alpha_in
    kappa_end=kappa
    Gamma_end=Gamma
    g0_end=g0
    animate_clicked_button(button_element)
    if(sweep_active) {
        fresh_sweep()
    }
}

function define_Vsweep_start(button_element) {
    query_all_parameters()
    Detuning_Vstart=Detuning
    alpha_in_Vstart=alpha_in
    kappa_Vstart=kappa
    Gamma_Vstart=Gamma
    g0_Vstart=g0
    animate_clicked_button(button_element)
    if(sweep_active) {
        fresh_sweep()
    }
}

function define_Vsweep_end(button_element) {
    query_all_parameters()
    Detuning_Vend=Detuning
    alpha_in_Vend=alpha_in
    kappa_Vend=kappa
    Gamma_Vend=Gamma
    g0_Vend=g0
    animate_clicked_button(button_element)
    if(sweep_active) {
        fresh_sweep()
    }
}

function activate_sweep(checkboxbutton) {
    if(checkboxbutton.checked) {
        sweep_active=true
        if(sweep2d_active) {
            hide_canvas()
            fresh_sweep()
        } else {
            do_sweep(0)
        }
    } else {
        sweep_active=false
        if(sweep2d_active) {
            canvas2d.remove()
            canvas2d=null
            unhide_canvas()
        }
        reset_X_alpha_records()
        change_X_alpha2_plot_labels(PLOT_LABEL_VS_TIME)
    }
}

function reset_X_alpha_records() {
    for(var j=0;j<max_time_idx;j++) {
        X_record[j]=0.0
        alpha2_record[j]=0.0
    }

}

function switch_kinetic_average(checkboxbutton) {
    if(checkboxbutton.checked) {
        sweep_show_kinetic_average=true
    } else {
        sweep_show_kinetic_average=false
    }
    if(sweep_active) {
        fresh_sweep()
    }
}

function activate_sweep2d(checkboxbutton) {
    if(checkboxbutton.checked) {
        sweep2d_active=true
        if(sweep_active) {
            hide_canvas()
            fresh_sweep()
        }
    } else {
        sweep2d_active=false
        canvas2d.remove()
        canvas2d=null
        unhide_canvas()
    }
}

function show_parameter_URL() {
    var field=document.getElementById("parameter_URL_field")
    field.innerHTML=get_URL_with_parameters()
    selectText(field)
}

function selectText(node) {
    if (document.body.createTextRange) {
        const range = document.body.createTextRange();
        range.moveToElementText(node);
        range.select();
    } else if (window.getSelection) {
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(node);
        selection.removeAllRanges();
        selection.addRange(range);
    } else {
        console.warn("Could not select text in node: Unsupported browser.");
    }
}

// graphics

function circle(x, y, r,color) {
	var shape = document.createElementNS ('http://www.w3.org/2000/svg', 'circle')
	shape.setAttribute ('cx', x)
	shape.setAttribute ('cy', y)
	shape.setAttribute ('r', r)
	shape.setAttribute('fill',color)
	canvas.appendChild(shape)
	return(shape)
}

function setAttributes(elem,attributes) {
    for (var i = 1; i < attributes.length; i+=2) {
        elem.setAttribute(attributes[i],attributes[i+1])
    }
}

function add_graphics() {
    args=Array.from(arguments)
    var shape = document.createElementNS("http://www.w3.org/2000/svg", args[0])
    setAttributes(shape,args)
    canvas.appendChild(shape)
    return shape
}

function add_graphics_no_canvas() {
    args=Array.from(arguments)
    var shape = document.createElementNS("http://www.w3.org/2000/svg", args[0])
    setAttributes(shape,args)
    return shape
}

function HTMLObject(x,y,width,height,htmlcode,textstyle) {
    var fo= document.createElementNS ('http://www.w3.org/2000/svg', 'foreignObject')
    fo.setAttribute("x",x)
    fo.setAttribute("y",y)
    fo.setAttribute("width",width)
    fo.setAttribute("height",height)         
    var newDiv = document.createElement('div')
    newDiv.style=textstyle
    newDiv.innerHTML=htmlcode
    fo.appendChild(newDiv)
    canvas.appendChild(fo)
    return(fo)
}

class Plot {
    constructor(x0,y0,width,height,color,linewidth,fillcolor,bordercolor,borderwidth) {
        this.x0=x0
        this.y0=y0
        this.width=width
        this.height=height
        this.color=color
        this.linewidth=linewidth
        this.shape=null

        this.background_shape=add_graphics("rect","x",x0,"y",y0-height,"width",width,"height",height,
        "fill",fillcolor,"stroke",bordercolor,"stroke-width",borderwidth)

        this.ticks_horizontal=new TickMarks(y0,TICKMARKS_LENGTH,TICKMARKS_COLOR,TICKMARKS_LINEWIDTH,true)
        this.ticks_vertical=new TickMarks(x0,TICKMARKS_LENGTH,TICKMARKS_COLOR,TICKMARKS_LINEWIDTH,false)
    }

    draw(x,y) {
        var string,X,Y
        var j,N=x.length

        var maxy=Math.max(...y)
        var miny=Math.min(...y)
        var maxx=Math.max(...x)
        var minx=Math.min(...x)
        if(maxx-minx<1e-6) { maxx=minx+1e-6 }
        if(maxy-miny<1e-6) { maxy=miny+1e-6 }
        this.sy=-this.height/(maxy-miny)
        this.sx=this.width/(maxx-minx)
        this.yshift=this.y0-miny*this.sy
        this.xshift=this.x0-minx*this.sx

        for(j=0;j<N;j++) {
            X=x[j]
            Y=y[j]
            if(j==0) {
                string=X+","+Y
            } else {
                string+=" "+X+","+Y
            }
        }

        this.transform="translate("+this.xshift+","+this.yshift+") scale("+this.sx+","+this.sy+")"
        if(this.shape!=null) {
            this.shape.setAttribute("points",string)
            this.shape.setAttribute("transform",this.transform)
        } else {
            this.shape=add_graphics("polyline","points",string,"stroke",this.color,"stroke-width",
            this.linewidth, "stroke-linejoin", "round", "vector-effect","non-scaling-stroke",
            "fill","none","transform",this.transform)
        }

        this.ticks_horizontal.scale=this.sx
        this.ticks_horizontal.xshift=this.xshift
        this.ticks_horizontal.set_values_from_range(minx,maxx)

        this.ticks_vertical.scale=this.sy
        this.ticks_vertical.xshift=this.yshift
        this.ticks_vertical.set_values_from_range(miny,maxy)
    }
}

// routines for the 2d image (2d sweep)
function init_img_canvas(width,height) { // prepare img
    if(canvas2d!=null) {
        canvas2d.remove()
    }
    canvas2d = document.createElement('canvas');

    canvas2d_width=width
    canvas2d_height=height
    canvas2d_N=width*height
    canvas2d.id = "canvas2d";
    canvas2d.width = width;
    canvas2d.height = height;
    canvas2d.style.zIndex = 8;
    canvas2d.style.border = "1px solid";
    canvas2d.style.float="left"

    document.body.insertBefore(canvas2d,document.getElementById("sidebar"))
    canvas2d_ctx=canvas2d.getContext('2d')
    canvas2d_img=canvas2d_ctx.createImageData(canvas2d_width,canvas2d_height)
    canvas2d_values=new Array(canvas2d_N)
    canvas2d_red=new Array(canvas2d_N)
    canvas2d_green=new Array(canvas2d_N)
    canvas2d_blue=new Array(canvas2d_N)
}

function canvas2d_draw_img() { // draw the img contained inside red,green,blue
    var j,k

    for(j=0;j<canvas2d_N;j++) {
        k=4*j
        canvas2d_img.data[k]=255*canvas2d_red[j]
        canvas2d_img.data[k+1]=255*canvas2d_green[j]
        canvas2d_img.data[k+2]=255*canvas2d_blue[j]
        canvas2d_img.data[k+3]=255
    }
    canvas2d_ctx.putImageData(canvas2d_img,0,0)
}

class TickMarks {
    constructor(y0,dy,color,linewidth,horizontal) {
        this.y0=y0
        this.dy=dy
        this.color=color
        this.linewidth=linewidth
        this.horizontal=horizontal
        this.shape=null
        this.labels_style="font-size:2;fill:white;font-family:Helvetica;font-weight:100"
        if(horizontal) {
            this.text_offset=3 
            this.text_extra_offset=0
        } else {
            this.text_offset=-7
            this.text_extra_offset=-3
        }
        this.scale=1
        this.xshift=0
        this.xmin=-1e12
        this.xmax=-1e12
    }

    set_values(xvalues) {
        this.xvalues=xvalues
        this.draw()
    }

    set_values_from_range(xmin,xmax) {
        if(xmin==this.xmin && xmax==this.xmax) { 
            return // do not redraw unnecessarily
        } else { 
            this.xmin=xmin
            this.xmax=xmax
        }
        var xstep=Math.pow(10,Math.ceil(Math.log10(xmax-xmin))-1)
        
        this.xvalues=[]
        if((xmax-xmin)/xstep>6) {
            xstep*=2
        } else {
            if(this.horizontal) {
                if((xmax-xmin)/xstep<=3) {
                    xstep/=2
                }                
            } else {
                if((xmax-xmin)/xstep<2) {
                    xstep/=2
                }
            }
        }
        for(var X=Math.ceil(xmin/xstep)*xstep;X<=xmax;X+=xstep) {
            this.xvalues.push(X)
        }
        this.draw()
    }

    draw_labels() {
        var n=this.xvalues.length

        if(this.labels_shape!=null) {
            this.labels_shape.remove()
        }

        this.labels_shape=add_graphics_no_canvas("g")

        if(this.horizontal) { var x_arg="x"; var y_arg="y"; } else { var x_arg="y"; var y_arg="x"; }

        var offset=this.text_offset
        // get extra text offset in case there will be "1.5e+3" or similar
        if(Math.abs(this.xmax)<1e-3 || Math.abs(this.xmin)<1e-3) { offset+=this.text_extra_offset }
        if(Math.abs(this.xmax)>1e3 || Math.abs(this.xmin)>1e3) { offset+=this.text_extra_offset }

        for(var j=0;j<n;j++) {
            var txt=add_graphics_no_canvas("text",x_arg,(this.xvalues[j]*this.scale+this.xshift),
                y_arg,this.y0+offset,"style",this.labels_style,"vector-effect","non-scaling-size")
            txt.innerHTML=this.xvalues[j].toPrecision(3)
            this.labels_shape.appendChild(txt)
        }
    }

    draw() {
        var path_string
        var n=this.xvalues.length, path_string=""

        // TICKS
        if(this.horizontal) {
            for(var j=0;j<n;j++) {
                path_string+=" M "+(this.xvalues[j]*this.scale+this.xshift)+" "+this.y0+" v "+this.dy
            }
        } else {
            for(var j=0;j<n;j++) {
                path_string+=" M "+this.y0+" "+(this.xvalues[j]*this.scale+this.xshift)+" h "+(-this.dy)
            }
        }

        if(this.shape==null) {
            this.shape=add_graphics_no_canvas("path","d",path_string,"stroke",this.color,
            "stroke-width",this.linewidth)
            canvas.appendChild(this.shape)
        } else { // only update, object already exists:
            this.shape.setAttribute("d",path_string)
        }

        // LABELS
        this.draw_labels()
        canvas.appendChild(this.labels_shape)
    }
}

// Runge Kutta and animation

function rhs(Y) {
    // Y=[Position,Velocity,alpha_re,alpha_im]
    Delta=Detuning+g0*Y[0]
    return( [Y[1],-Y[0] - Gamma*Y[1] + 2*g0*(Y[3]*Y[3]+Y[2]*Y[2]) ,-Delta*Y[3]-0.5*kappa*Y[2]+LaserDrive, Delta*Y[2]-0.5*kappa*Y[3]] )
}

function add_mul(c,a,lambda,b) { // set c=a+lambda*b for whole arrays
    for(j=0;j<a.length;j++) {
        c[j]=a[j]+lambda*b[j]
    }
}

// Runge Kutta 4th order
function rkstep() {
    dX1=rhs(X)
    add_mul(Xnew,X,0.5*DT,dX1)
    dX2=rhs(Xnew)
    add_mul(Xnew,X,0.5*DT,dX2)
    dX3=rhs(Xnew)
    add_mul(Xnew,X,DT,dX3)
    dX4=rhs(Xnew)
    for(j=0;j<X.length;j++) {
        X[j]+=DT6*(dX1[j]+2*dX2[j]+2*dX3[j]+dX4[j])
    }
}

function plot_X_and_alpha2(horiz_values) { // update both plot panels
    shape_timetrace.draw(horiz_values,X_record)
    shape_alpha2_timetrace.draw(horiz_values,alpha2_record)
}

function change_X_alpha2_plot_labels(label_vs_what) {
    shape_timetrace_label.children[0].innerHTML=PLOT_LABEL_BEGIN+X_PLOT_LABEL+label_vs_what+PLOT_LABEL_END
    shape_alpha2_timetrace_label.children[0].innerHTML=PLOT_LABEL_BEGIN+ALPHA_PLOT_LABEL+label_vs_what+PLOT_LABEL_END
}

function hide_canvas() {
    canvas.style.display="none"
}

function unhide_canvas() {
    hide_sweep2d_label_boxes()
    canvas.style.display="block"
}

function create_sweep2d_label_boxes() {
    sweep_label=document.createElement("p")
    sweep_label.style.position="absolute"
    sweep_label.style.left="400px"
    sweep_label.style.top="530px"
    sweep_label.style.fontFamily="Helvetica"
    sweep_label.style.fontWeight="100"
    sweep_label.style.fontSize="20px"
    sweep_label.style.color="white"
    sweep_label.style.backgroundColor="rgba(0,150,200,0.5)"
    sweep_label.style.borderRadius="5px"
    sweep_label.style.padding="5px"

    sweep_V_label=document.createElement("p")
    sweep_V_label.style.position="absolute"
    sweep_V_label.style.left="-80px"
    sweep_V_label.style.top="200px"
    sweep_V_label.style.fontFamily="Helvetica"
    sweep_V_label.style.fontSize="20px"
    sweep_V_label.style.fontWeight="100"
    sweep_V_label.style.color="white"
    sweep_V_label.style.transform="rotate(-90deg)"
    sweep_V_label.style.backgroundColor="rgba(0,150,200,0.5)"
    sweep_V_label.style.borderRadius="5px"
    sweep_V_label.style.padding="5px"

    document.body.insertBefore(sweep_label,null)
    document.body.insertBefore(sweep_V_label,null)
}

function hide_sweep2d_label_boxes() {
    sweep_label.remove()
    sweep_V_label.remove()
}

function canvas2d_obtain_min_max_values() {
    var val_min=1e6
    var val_max=-1e6
    for(var j=0;j<max_V_idx;j++) {
        for(var k=0;k<max_time_idx;k++) {
            var v=canvas2d_values[k+j*width]
            if(v<val_min) { val_min=v }
            if(v>val_max) { val_max=v }
        }
    }
    return([val_min,val_max])     
}

function plot_sweep_batch(start,stop) {
    minmax=canvas2d_obtain_min_max_values()
    val_min=minmax[0]
    val_max=minmax[1]

    val_scale=1.0/(val_max-val_min)
    for(var j=start;j<=stop;j++) {
        for(var k=0;k<max_time_idx;k++) {
            v=val_scale*(canvas2d_values[k+j*width]-val_min)
            canvas2d_red[k+j*width]=v
            canvas2d_green[k+j*width]=v*v
            canvas2d_blue[k+j*width]=v*(1-v)
        }
    }
    // finally, draw!
    canvas2d_draw_img()
}

function do_sweep(v_idx) {
    var sweep_label_text
    var time_idx=0
    var tmax=max_time_idx*DT
    const SMALL_NUMBER=1e-10
    
    // check which parameters are really swept for the normal sweep
    if(Math.abs(Detuning_end-Detuning_start)<SMALL_NUMBER) { Detuning_sweep=false } else { Detuning_sweep=true }
    if(Math.abs(alpha_in_end-alpha_in_start)<SMALL_NUMBER) { alpha_in_sweep=false } else { alpha_in_sweep=true }
    if(Math.abs(kappa_end-kappa_start)<SMALL_NUMBER) { kappa_sweep=false } else { kappa_sweep=true }
    if(Math.abs(Gamma_end-Gamma_start)<SMALL_NUMBER) { Gamma_sweep=false } else { Gamma_sweep=true }
    if(Math.abs(g0_end-g0_start)<SMALL_NUMBER) { g0_sweep=false } else { g0_sweep=true }

    if(sweep2d_active) { // a 2d image/sweep
        // check which parameters participate in the vertical sweep
        if(Math.abs(Detuning_Vend-Detuning_Vstart)<SMALL_NUMBER) { Detuning_Vsweep=false } else { Detuning_Vsweep=true }
        if(Math.abs(alpha_in_Vend-alpha_in_Vstart)<SMALL_NUMBER) { alpha_in_Vsweep=false } else { alpha_in_Vsweep=true }
        if(Math.abs(kappa_Vend-kappa_Vstart)<SMALL_NUMBER) { kappa_Vsweep=false } else { kappa_Vsweep=true }
        if(Math.abs(Gamma_Vend-Gamma_Vstart)<SMALL_NUMBER) { Gamma_Vsweep=false } else { Gamma_Vsweep=true }
        if(Math.abs(g0_Vend-g0_Vstart)<SMALL_NUMBER) { g0_Vsweep=false } else { g0_Vsweep=true }
        max_V_idx=max_V_sweep_idx
        width=max_time_idx
        height=max_V_sweep_idx
        if(canvas2d==null || canvas2d_width!=width || canvas2d_height!=height) {
            if(canvas2d==null) {
                var really_new=true                
            } else {
                var really_new=false
            }

            init_img_canvas(width,height)

            if(really_new) {
                create_sweep2d_label_boxes()
            }
        }
        if(V_idx==0) {  // starting new 2d sweep
            // delete canvas2d
            for(var j=0;j<canvas2d_N;j++) {
                canvas2d_red[j]=0.3
                canvas2d_green[j]=0.0
                canvas2d_blue[j]=0.0
                canvas2d_values[j]=0.0
            }

            if(Detuning_sweep) { sweep_label.innerHTML=DETUNING_TEXT+" ("+Detuning_start.toPrecision(3)+"..."+Detuning_end.toPrecision(3)+")" }
            if(alpha_in_sweep) { sweep_label.innerHTML=ALPHA_TEXT+" ("+alpha_in_start.toPrecision(3)+"..."+alpha_in_end.toPrecision(3)+")" }
            if(kappa_sweep) { sweep_label.innerHTML=KAPPA_TEXT+" ("+kappa_start.toPrecision(3)+"..."+kappa_end.toPrecision(3)+")" }
            if(Gamma_sweep) { sweep_label.innerHTML=GAMMA_TEXT+" ("+Gamma_start.toPrecision(3)+"..."+Gamma_end.toPrecision(3)+")" }
            if(g0_sweep) { sweep_label.innerHTML=G0_TEXT+" ("+g0_start.toPrecision(3)+"..."+g0_end.toPrecision(3)+")" }
        
            if(Detuning_Vsweep) { sweep_V_label.innerHTML=DETUNING_TEXT+" ("+Detuning_Vstart.toPrecision(3)+"..."+Detuning_Vend.toPrecision(3)+")" }
            if(alpha_in_Vsweep) { sweep_V_label.innerHTML=ALPHA_TEXT+" ("+alpha_in_Vstart.toPrecision(3)+"..."+alpha_in_Vend.toPrecision(3)+")" }
            if(kappa_Vsweep) { sweep_V_label.innerHTML=KAPPA_TEXT+" ("+kappa_Vstart.toPrecision(3)+"..."+kappa_Vend.toPrecision(3)+")" }
            if(Gamma_Vsweep) { sweep_V_label.innerHTML=GAMMA_TEXT+" ("+Gamma_Vstart.toPrecision(3)+"..."+Gamma_Vend.toPrecision(3)+")" }
            if(g0_Vsweep) { sweep_V_label.innerHTML=G0_TEXT+" ("+g0_Vstart.toPrecision(3)+"..."+g0_Vend.toPrecision(3)+")" }
        }
    } else { // just a 1d sweep
        max_V_idx=1
        if(Detuning_sweep) { sweep_label_text=DETUNING_TEXT }
        if(alpha_in_sweep) { sweep_label_text=ALPHA_TEXT }
        if(kappa_sweep) { sweep_label_text=KAPPA_TEXT }
        if(Gamma_sweep) { sweep_label_text=GAMMA_TEXT }
        if(g0_sweep) { sweep_label_text=G0_TEXT }
    }

    if(sweep2d_active) {
        sv=1-v_idx/max_V_idx
        if(Detuning_Vsweep) { Detuning=(1-sv)*Detuning_Vstart+sv*Detuning_Vend }
        if(alpha_in_Vsweep) { alpha_in=(1-sv)*alpha_in_Vstart+sv*alpha_in_Vend }
        if(kappa_Vsweep) { kappa=(1-sv)*kappa_Vstart+sv*kappa_Vend }
        if(Gamma_Vsweep) { Gamma=(1-sv)*Gamma_Vstart+sv*Gamma_Vend }
        if(g0_Vsweep) { g0=(1-sv)*g0_Vstart+sv*g0_Vend }  
    }

    // prepare initial values for sweep
    X=[0.,0.,0.,0.]
    var kin_average=0.0
    var kin_average_rate=DT/kinetic_amplitude_averaging_time
    var DT_big_step=sweep_time/max_time_idx
    var t=0.0
    var t_step=0.0

    var sweep_values=new Array(max_time_idx)

    // do sweep (change parameters while evolving in time)
    for(time_idx=0;time_idx<max_time_idx;time_idx++) {
        s=time_idx*DT/tmax
        if(Detuning_sweep) { Detuning=sweep_value=(1-s)*Detuning_start+s*Detuning_end }
        if(alpha_in_sweep) { alpha_in=sweep_value=(1-s)*alpha_in_start+s*alpha_in_end }
        if(kappa_sweep) { kappa=sweep_value=(1-s)*kappa_start+s*kappa_end }
        if(Gamma_sweep) { Gamma=sweep_value=(1-s)*Gamma_start+s*Gamma_end }
        if(g0_sweep) { g0=sweep_value=(1-s)*g0_start+s*g0_end }
        LaserDrive=Math.sqrt(kappa)*alpha_in

        t_step=t_step+DT_big_step
        while(t<t_step) {
            rkstep()
            kin_average+=kin_average_rate*(X[1]*X[1]-kin_average)
            t+=DT
        }

        // keep records of time traces
        if(sweep_show_kinetic_average) {
            X_record[time_idx]=Math.sqrt(2*kin_average)
        } else {
            X_record[time_idx]=X[0]
        }
        alpha2_record[time_idx]=X[2]*X[2]+X[3]*X[3]

        sweep_values[time_idx]=sweep_value
    }

    if(sweep2d_active) {
        for(var k=0;k<max_time_idx;k++) {
            canvas2d_values[k+v_idx*width]=X_record[k]
        }
        if((v_idx+1)%canvas2d_batch==0) {
            plot_sweep_batch(v_idx-canvas2d_batch+1,v_idx)
        }
    } else {
        plot_X_and_alpha2(sweep_values)
        change_X_alpha2_plot_labels(" vs "+sweep_label_text)
    }
}

function animate() {
    if(!sweep_active) { // if we are not currently in sweeping mode
        rkstep()

        // keep records of time traces
        X_record[time_idx]=X[0]
        alpha2_record[time_idx]=X[2]*X[2]+X[3]*X[3]
        time_idx+=1
        if(time_idx>=max_time_idx) { // wrap around
            time_idx=0
        }

        // show graphics (update plots)
        if(MASSPOINT_ENABLED) {
            shape_mass_point.setAttribute("cx",MASSPOINT_X0+MASSPOINT_XSCALE*X[0])
        }
        plot_X_and_alpha2(times_record)
    } else {
        if(sweep2d_active) {
            if(V_idx<max_V_sweep_idx) {
                do_sweep(V_idx)
                V_idx+=1
            } else {
                if(V_idx==max_V_sweep_idx) { // replot once on final display
                    plot_sweep_batch(0,max_V_sweep_idx-1) // nicely color-scaled plot redrawn in the end
                    V_idx++
                }
            }
        }
    }
}

// saving parameters in URLs and loading them again

function save_parameters_to_string() { // convert parameters into text string
    args=Array.from(arguments)
    string=""
    for(j=0;j<args.length;j+=2) {
        string=string+args[j]+"="+args[j+1]+";"
    }
    return(string)
}

function get_param(name) {
    var patt = new RegExp(name+"=([^;]*);",'g')
    matches=patt.exec(parameter_string)
    if(matches) {
        return(matches[1])
    } else {
        return(null)
    }
}

function save_parameters() { // save parameters to parameter_string
    query_all_parameters()
    parameter_string=save_parameters_to_string("Detuning",Detuning,"kappa",kappa,"Gamma",Gamma,"g0",g0,
    "alpha_in",alpha_in,
    "Detuning_start",Detuning_start, "Detuning_end", Detuning_end,
    "kappa_start", kappa_start, "kappa_end", kappa_end,
    "Gamma_start", Gamma_start, "Gamma_end", Gamma_end,
    "g0_start", g0_start, "g0_end", g0_end,
    "alpha_in_start", alpha_in_start, "alpha_in_end", alpha_in_end,
    "Detuning_Vstart",Detuning_Vstart, "Detuning_Vend", Detuning_Vend,
    "kappa_Vstart", kappa_Vstart, "kappa_Vend", kappa_Vend,
    "Gamma_Vstart", Gamma_Vstart, "Gamma_Vend", Gamma_Vend,
    "g0_Vstart",   g0_Vstart, "g0_Vend", g0_Vend,
    "alpha_in_Vstart", alpha_in_Vstart, "alpha_in_Vend", alpha_in_Vend,
    "sweep_time",sweep_time)
}

function get_several_params() {
    args=Array.from(arguments)
    values=new Array(args.length)
    for(j=0;j<args.length;j++) {
        values[j]=parseFloat(get_param(args[j]))
    }
    return(values)
}

function load_parameters() { // load parameters out of the current parameter_string
    document.getElementById('detuning_input').value=get_param("Detuning")
    document.getElementById('kappa_input').value=get_param("kappa")
    document.getElementById('gamma_input').value=Math.log10(get_param("Gamma"))
    document.getElementById('g0_input').value=get_param("g0")
    document.getElementById('alpha_in_input').value=Math.log10(Math.pow(get_param("alpha_in"),2))
    document.getElementById('sweep_time_input').value=Math.log10(get_param(sweep_time))

    p=get_several_params("Detuning_start","Detuning_end","kappa_start","kappa_end","Gamma_start",
    "Gamma_end","g0_start","g0_end", "alpha_in_start", "alpha_in_end", "Detuning_Vstart",
    "Detuning_Vend", "kappa_Vstart", "kappa_Vend", "Gamma_Vstart", "Gamma_Vend", "g0_Vstart",
    "g0_Vend", "alpha_in_Vstart", "alpha_in_Vend")
    
    Detuning_start=p[0]
    Detuning_end=p[1]
    kappa_start=p[2] 
    kappa_end=p[3]
    Gamma_start=p[4] 
    Gamma_end=p[5]
    g0_start=p[6] 
    g0_end=p[7]
    alpha_in_start=p[8] 
    alpha_in_end=p[9]
    Detuning_Vstart=p[10]
    Detuning_Vend=p[11]
    kappa_Vstart=p[12] 
    kappa_Vend=p[13]
    Gamma_Vstart=p[14]
    Gamma_Vend=p[15]
    g0_Vstart=p[16]
    g0_Vend=p[17]
    alpha_in_Vstart=p[18] 
    alpha_in_Vend=p[19]

    query_all_parameters()
    change_sweep_time()
}

function get_URL_with_parameters() {
    leading_part=window.location.href.split("?")[0]
    save_parameters()
    return(leading_part+"?"+parameter_string)
}

function load_parameters_from_URL() {
    parts=window.location.href.split("?")
    if(parts.length>1) {
        parameter_string=parts[1]
        load_parameters()
    }
}



//============ MAIN ==========
// Setting up parameters and graphics, starting animation

// Graphics parameters
MASSPOINT_X0=50
MASSPOINT_Y0=70
MASSPOINT_XSCALE=0.01
MASSPOINT_RADIUS=3
MASSPOINT_ENABLED=false

TIMETRACE_COLOR="orange"
TIMETRACE_LINEWIDTH=2
PLOT_BACKGROUND_COLOR="dimgrey"
PLOT_BORDER_COLOR="white"
PLOT_BORDER_WIDTH=0.2
PLOT_LABEL_HEIGHT=6
PLOT_LABEL_SHIFT=-6
PLOT_LABEL_BACKGROUND_COLOR="orange"
PLOT_LABEL_TEXT_COLOR="white"
PLOT_LABEL_BEGIN="<p style='margin:auto;background-color:rgba(0,150,200,0.8);display:inline-block;padding:1px;border-radius:2px'>"
PLOT_LABEL_END="</p>"
PLOT_LABEL_TEXT_STYLE="font-size:2;font-family:Helvetica;font-weight:100;color:white"


DETUNING_TEXT="Detuning &Delta;/&Omega;"
KAPPA_TEXT="Cavity decay &kappa;/&Omega;"
GAMMA_TEXT="Mechanical damping &Gamma;/&Omega;"
G0_TEXT="Coupling g<sub>0</sub>/&Omega;"
ALPHA_TEXT="Drive amplitude &alpha;<sub>in</sub>/&Omega;<sup>1/2</sup>"

TIMETRACE_X0=15
TIMETRACE_Y0=50
TIMETRACE_XWIDTH=80
TIMETRACE_YWIDTH=10
X_PLOT_LABEL="Position x/x<sub>ZPF</sub>"

TIMETRACE_ALPHA2_Y0=25
TIMETRACE_ALPHA2_X0=15
TIMETRACE_ALPHA2_YWIDTH=10
TIMETRACE_ALPHA2_XWIDTH=80
ALPHA_PLOT_LABEL="Intensity |&alpha;|<sup>2</sup>"

PLOT_LABEL_VS_TIME=" vs time &Omega;t"

TICKMARKS_LENGTH=1
TICKMARKS_COLOR="white"
TICKMARKS_LINEWIDTH=0.2


// Numerics parameters
DT=0.2
DT6=DT/6.0

// parameters for display
max_time_idx=1001 // how many points to store for displaying the time trace
max_V_sweep_idx=600
canvas2d=null
canvas2d_batch=10 // how many lines to display simultaneously in 2d sweep

// Physics
// Variables
X=[1.0,0.0,0.0,0.0] // position,velocity,real(alpha),imag(alpha)
Xnew=Array(X.length)

kinetic_amplitude_averaging_time=30.0 // about 5 oscillation periods

sweep_active=false // whether we are in sweeping mode
sweep2d_active=false
sweep_show_kinetic_average=false
alpha_in=1.0 // because it will be accessed in change_kappa already

// sweep parameters (such that they are defined even in the beginning)
// note: the way this works is that *only those parameters where start and end differ* will
// define the sweep. This is true both for the horizontal and the vertical ('V') sweep.
Detuning_start=-2
Detuning_end=2
kappa_start=1
kappa_end=1
Gamma_start=0.1
Gamma_end=0.1
g0_start=0.0001
g0_end=0.0001
alpha_in_start=10
alpha_in_end=10
Detuning_Vstart=0
Detuning_Vend=0
kappa_Vstart=1
kappa_Vend=1
Gamma_Vstart=0.1
Gamma_Vend=0.1
g0_Vstart=0.0001
g0_Vend=0.0001
alpha_in_Vstart=1
alpha_in_Vend=1e3


// Parameters: Obtain them from sliders for the first time
query_all_parameters()
change_sweep_time()

// now check whether maybe we have parameters sitting in the URL and use them instead!
load_parameters_from_URL()

// prepare time trace
X_record=new Array(max_time_idx)
alpha2_record=new Array(max_time_idx)
times_record=new Array(max_time_idx)
for(j=0;j<max_time_idx;j++) {
    times_record[j]=j*DT
    X_record[j]=0.0
    alpha2_record[j]=0.0
}
time_idx=0

// Preparing graphics
canvas=document.getElementById("canvas")
if(MASSPOINT_ENABLED) {
    shape_mass_point=circle(MASSPOINT_X0+MASSPOINT_XSCALE*X[0],MASSPOINT_Y0,MASSPOINT_RADIUS,"orange")
}

// plot of time trace (curve will be modified later)
shape_timetrace=new Plot(TIMETRACE_X0,TIMETRACE_Y0,TIMETRACE_XWIDTH,
    TIMETRACE_YWIDTH,TIMETRACE_COLOR,TIMETRACE_LINEWIDTH,
    PLOT_BACKGROUND_COLOR,PLOT_BORDER_COLOR,PLOT_BORDER_WIDTH)
shape_timetrace.draw(times_record,X_record)

shape_timetrace_label=HTMLObject(TIMETRACE_X0,TIMETRACE_Y0-TIMETRACE_ALPHA2_YWIDTH+PLOT_LABEL_SHIFT,TIMETRACE_XWIDTH,
PLOT_LABEL_HEIGHT,PLOT_LABEL_BEGIN+X_PLOT_LABEL+PLOT_LABEL_VS_TIME+PLOT_LABEL_END,PLOT_LABEL_TEXT_STYLE)
shape_timetrace_label.children[0].style.textAlign="center"

shape_alpha2_timetrace=new Plot(TIMETRACE_ALPHA2_X0,TIMETRACE_ALPHA2_Y0,TIMETRACE_ALPHA2_XWIDTH,
    TIMETRACE_ALPHA2_YWIDTH,TIMETRACE_COLOR,TIMETRACE_LINEWIDTH,
    PLOT_BACKGROUND_COLOR,PLOT_BORDER_COLOR,PLOT_BORDER_WIDTH)
shape_alpha2_timetrace.draw(times_record,alpha2_record)

shape_alpha2_timetrace_label=HTMLObject(TIMETRACE_ALPHA2_X0,TIMETRACE_ALPHA2_Y0-TIMETRACE_ALPHA2_YWIDTH+PLOT_LABEL_SHIFT,TIMETRACE_ALPHA2_XWIDTH,
PLOT_LABEL_HEIGHT,PLOT_LABEL_BEGIN+ALPHA_PLOT_LABEL+PLOT_LABEL_VS_TIME+PLOT_LABEL_END,PLOT_LABEL_TEXT_STYLE)
shape_alpha2_timetrace_label.children[0].style.textAlign="center"


// Start animation loop
setInterval(animate,20)

</script>


</body>
</html>
